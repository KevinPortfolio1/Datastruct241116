int a = 5;
int *p = &a;  // p 是指標，存儲變數 a 的位址

位址（Address）：
位址是指記憶體中某個位置的具體位置（地址）。每個變數都會被分配一個記憶體位址，指標變數用來儲存這個位址。
在上面的例子中，&a 就是變數 a 的位址。

值（Value）：
值是變數所持有的具體資料。例如，a 的值是 5，這意味著變數 a 存儲了數字 5。
如果你想通過指標來讀取變數的值，可以使用解引用運算子 *，這樣可以通過指標訪問該位址上儲存的值：
int b = *p;  // 解引用指標 p，獲得指標所指向的變數的值

指標 malloc vs new


在 C++ 中，malloc 和 new 都是用來在堆積區域（heap）分配記憶體的方式，但它們有些重要的區別。
這些差異不僅涉及語法和使用方式，還涉及記憶體管理和初始化。

1. malloc (Memory Allocation)
malloc 是 C 語言中的記憶體分配函數，也可以在 C++ 中使用。它用來在堆積區域分配一塊指定大小的記憶體。
語法：
void* malloc(size_t size);
    返回值：malloc 返回的是一個 void*，這意味著返回的是無型別的記憶體地址。因此，你通常需要將返回的指標強制轉型成所需型別的指標。
    初始化：malloc 不會自動初始化記憶體。新分配的記憶體中的內容是未定義的，即可能包含垃圾數據。
    釋放記憶體：記憶體必須使用 free() 函數手動釋放。
範例：
int* p = (int*)malloc(sizeof(int));  // 分配一個 int 大小的記憶體
if (p != NULL) {
    *p = 10;  // 使用分配的記憶體
    free(p);  // 釋放記憶體
}

2. new (C++ 中的記憶體分配)
new 是 C++ 引入的記憶體分配運算符，它不僅分配記憶體，還能調用構造函數來初始化物件。
語法：
new_type* ptr = new type;
    返回值：new 返回的是指定類型的指標。它會自動根據指定的類型返回記憶體位置，不需要進行強制轉型。
    初始化：new 會自動初始化記憶體。如果是基本類型（如 int、float 等），則會初始化為零或執行其他預設操作（視編譯器設定）。如果是物件類型，則會調用類型的構造函數。
    釋放記憶體：記憶體必須使用 delete 或 delete[] 來釋放，取決於是分配了單一物件還是陣列。
範例：
int* p = new int;  // 分配一個 int 的記憶體
*p = 10;            // 使用分配的記憶體
delete p;           // 釋放記憶體

3. 關鍵差異
特徵	malloc	                                      new
語言	C 和 C++ 中都能使用	                         只有 C++ 中使用
返回型別	void*，需要強制轉型	                     直接返回所需型別的指標
初始化	不初始化記憶體（垃圾數據）	                 初始化記憶體（基礎類型為 0，物件會調用構造函數）
釋放記憶體	使用 free()	                             使用 delete 或 delete[]
適用對象	主要用於 C 語言，對象的構造不會自動呼叫	 主要用於 C++，能自動呼叫構造函數

4. malloc vs new 的選擇
    在 C++ 中，推薦使用 new 而不是 malloc，因為：
        new 會調用構造函數來初始化物件，這對於物件管理非常重要。
        new 更符合 C++ 的語法和慣例，使得 C++ 程式碼更具可讀性和一致性。
        new 和 delete 是 C++ 記憶體管理的一部分，而 malloc 和 free 更適合 C 語言。
malloc 主要是用於 C 語言中，或者在 C++ 中需要手動處理記憶體時，也可以使用 malloc。
但在現代 C++ 開發中，new 和 delete 是更好的選擇。

5. 小結

    如果你在 C++ 中使用 malloc，你失去了 C++ 的對象管理功能（例如，構造函數的調用），而且記憶體分配後不會初始化數據。
    使用 new 更適合 C++，因為它可以讓你進行更簡潔且安全的內存分配，並自動處理初始化和記憶體管理。